/**
 * Infrastructure as Code (IaC) Generation Service
 * Generates Terraform, Kubernetes, CloudFormation, Pulumi, Ansible
 */

import type {
  Diagram,
  DiagramNode,
  DiagramEdge,
} from '../store/types';
import type {
  IaCConfig,
  IaCOptions,
  IaCOutput,
  IaCFile,
  TerraformModule,
  KubernetesManifest,
} from '../store/integrationTypes';

// ============================================================================
// IaC Generator Base Class
// ============================================================================

export abstract class IaCGenerator {
  protected diagram: Diagram;
  protected options: IaCOptions;

  constructor(diagram: Diagram, options: IaCOptions = {}) {
    this.diagram = diagram;
    this.options = {
      modulesEnabled: true,
      bestPractices: true,
      includeNetworking: true,
      includeMonitoring: false,
      includeSecurity: true,
      environment: 'production',
      ...options,
    };
  }

  abstract generate(): IaCOutput;

  protected getNodesByType(type: string): DiagramNode[] {
    return this.diagram.nodes.filter((n) => n.type === type);
  }

  protected findDependencies(nodeId: string): DiagramEdge[] {
    return this.diagram.edges.filter((e) => e.source === nodeId || e.target === nodeId);
  }
}

// ============================================================================
// Terraform Generator
// ============================================================================

export class TerraformGenerator extends IaCGenerator {
  generate(): IaCOutput {
    const files: IaCFile[] = [];

    // Generate main.tf
    files.push(this.generateMainTf());

    // Generate variables.tf
    files.push(this.generateVariablesTf());

    // Generate outputs.tf
    files.push(this.generateOutputsTf());

    // Generate provider.tf
    files.push(this.generateProviderTf());

    // Generate modules if enabled
    if (this.options.modulesEnabled) {
      files.push(...this.generateModules());
    }

    // Generate networking if enabled
    if (this.options.includeNetworking) {
      files.push(this.generateNetworkingTf());
    }

    // Generate security groups if enabled
    if (this.options.includeSecurity) {
      files.push(this.generateSecurityTf());
    }

    return {
      provider: 'terraform',
      files,
      resources: this.extractResources(files),
    };
  }

  private generateMainTf(): IaCFile {
    const serverNodes = this.getNodesByType('serverNode');
    const databaseNodes = this.getNodesByType('databaseNode');
    const cacheNodes = this.getNodesByType('cacheNode');
    const lbNodes = this.getNodesByType('loadBalancerNode');

    let content = `# Generated by System Design Visualizer
# Diagram: ${this.diagram.name}
# Environment: ${this.options.environment}

terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

`;

    // Generate EC2 instances for servers
    for (const node of serverNodes) {
      const resourceName = this.sanitizeName(node.id);
      content += `
# ${node.data.label}
resource "aws_instance" "${resourceName}" {
  ami           = var.ami_id
  instance_type = var.instance_type_${resourceName}

  tags = {
    Name        = "${node.data.label}"
    Environment = var.environment
    ManagedBy   = "terraform"
    Description = "${node.data.description || ''}"
  }

  vpc_security_group_ids = [aws_security_group.${resourceName}.id]
  subnet_id              = aws_subnet.private.id

  user_data = <<-EOF
              #!/bin/bash
              echo "Setting up ${node.data.label}"
              # Add your initialization script here
              EOF

  lifecycle {
    create_before_destroy = true
  }
}

`;
    }

    // Generate RDS instances for databases
    for (const node of databaseNodes) {
      const resourceName = this.sanitizeName(node.id);
      content += `
# ${node.data.label}
resource "aws_db_instance" "${resourceName}" {
  identifier     = "${resourceName}"
  engine         = "postgres"
  engine_version = "15.3"
  instance_class = var.db_instance_class

  allocated_storage     = var.db_storage_size
  max_allocated_storage = var.db_max_storage_size
  storage_encrypted     = true

  db_name  = "${resourceName}db"
  username = var.db_username
  password = var.db_password

  vpc_security_group_ids = [aws_security_group.${resourceName}.id]
  db_subnet_group_name   = aws_db_subnet_group.main.name

  backup_retention_period = 7
  backup_window          = "03:00-04:00"
  maintenance_window     = "mon:04:00-mon:05:00"

  skip_final_snapshot       = var.environment != "production"
  final_snapshot_identifier = "${resourceName}-final-snapshot"

  tags = {
    Name        = "${node.data.label}"
    Environment = var.environment
  }
}

`;
    }

    // Generate ElastiCache for cache nodes
    for (const node of cacheNodes) {
      const resourceName = this.sanitizeName(node.id);
      content += `
# ${node.data.label}
resource "aws_elasticache_cluster" "${resourceName}" {
  cluster_id           = "${resourceName}"
  engine               = "redis"
  node_type            = var.cache_node_type
  num_cache_nodes      = 1
  parameter_group_name = "default.redis7"
  port                 = 6379

  security_group_ids = [aws_security_group.${resourceName}.id]
  subnet_group_name  = aws_elasticache_subnet_group.main.name

  tags = {
    Name        = "${node.data.label}"
    Environment = var.environment
  }
}

`;
    }

    // Generate ALB for load balancer nodes
    for (const node of lbNodes) {
      const resourceName = this.sanitizeName(node.id);
      content += `
# ${node.data.label}
resource "aws_lb" "${resourceName}" {
  name               = "${resourceName}"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.${resourceName}.id]
  subnets            = [aws_subnet.public_a.id, aws_subnet.public_b.id]

  enable_deletion_protection = var.environment == "production"

  tags = {
    Name        = "${node.data.label}"
    Environment = var.environment
  }
}

resource "aws_lb_target_group" "${resourceName}" {
  name     = "${resourceName}-tg"
  port     = 80
  protocol = "HTTP"
  vpc_id   = aws_vpc.main.id

  health_check {
    enabled             = true
    healthy_threshold   = 2
    interval            = 30
    matcher             = "200"
    path                = "/health"
    port                = "traffic-port"
    protocol            = "HTTP"
    timeout             = 5
    unhealthy_threshold = 2
  }
}

resource "aws_lb_listener" "${resourceName}" {
  load_balancer_arn = aws_lb.${resourceName}.arn
  port              = "443"
  protocol          = "HTTPS"
  ssl_policy        = "ELBSecurityPolicy-TLS-1-2-2017-01"
  certificate_arn   = var.ssl_certificate_arn

  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.${resourceName}.arn
  }
}

`;
    }

    return {
      path: 'main.tf',
      content,
      language: 'hcl',
      description: 'Main Terraform configuration',
    };
  }

  private generateVariablesTf(): IaCFile {
    let content = `# Variables

variable "environment" {
  description = "Environment name (dev, staging, production)"
  type        = string
  default     = "${this.options.environment}"
}

variable "region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "ami_id" {
  description = "AMI ID for EC2 instances"
  type        = string
  default     = "ami-0c55b159cbfafe1f0" # Amazon Linux 2
}

variable "db_username" {
  description = "Database master username"
  type        = string
  sensitive   = true
}

variable "db_password" {
  description = "Database master password"
  type        = string
  sensitive   = true
}

variable "db_instance_class" {
  description = "RDS instance class"
  type        = string
  default     = "db.t3.micro"
}

variable "db_storage_size" {
  description = "Initial database storage size in GB"
  type        = number
  default     = 20
}

variable "db_max_storage_size" {
  description = "Maximum database storage size in GB"
  type        = number
  default     = 100
}

variable "cache_node_type" {
  description = "ElastiCache node type"
  type        = string
  default     = "cache.t3.micro"
}

variable "ssl_certificate_arn" {
  description = "ARN of SSL certificate for HTTPS"
  type        = string
}

`;

    // Add instance type variables for each server
    const serverNodes = this.getNodesByType('serverNode');
    for (const node of serverNodes) {
      const resourceName = this.sanitizeName(node.id);
      content += `
variable "instance_type_${resourceName}" {
  description = "Instance type for ${node.data.label}"
  type        = string
  default     = "t3.micro"
}
`;
    }

    return {
      path: 'variables.tf',
      content,
      language: 'hcl',
      description: 'Terraform variables',
    };
  }

  private generateOutputsTf(): IaCFile {
    let content = `# Outputs

`;

    const lbNodes = this.getNodesByType('loadBalancerNode');
    for (const node of lbNodes) {
      const resourceName = this.sanitizeName(node.id);
      content += `
output "${resourceName}_dns" {
  description = "DNS name of ${node.data.label}"
  value       = aws_lb.${resourceName}.dns_name
}

output "${resourceName}_arn" {
  description = "ARN of ${node.data.label}"
  value       = aws_lb.${resourceName}.arn
}
`;
    }

    const databaseNodes = this.getNodesByType('databaseNode');
    for (const node of databaseNodes) {
      const resourceName = this.sanitizeName(node.id);
      content += `
output "${resourceName}_endpoint" {
  description = "Endpoint of ${node.data.label}"
  value       = aws_db_instance.${resourceName}.endpoint
  sensitive   = true
}
`;
    }

    return {
      path: 'outputs.tf',
      content,
      language: 'hcl',
      description: 'Terraform outputs',
    };
  }

  private generateProviderTf(): IaCFile {
    return {
      path: 'provider.tf',
      content: `# Provider Configuration

provider "aws" {
  region = var.region

  default_tags {
    tags = {
      Project     = "${this.diagram.name}"
      ManagedBy   = "Terraform"
      Environment = var.environment
    }
  }
}
`,
      language: 'hcl',
      description: 'Provider configuration',
    };
  }

  private generateNetworkingTf(): IaCFile {
    return {
      path: 'networking.tf',
      content: `# Networking Configuration

resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name = "${this.diagram.name}-vpc"
  }
}

resource "aws_subnet" "public_a" {
  vpc_id                  = aws_vpc.main.id
  cidr_block              = "10.0.1.0/24"
  availability_zone       = "\${var.region}a"
  map_public_ip_on_launch = true

  tags = {
    Name = "${this.diagram.name}-public-a"
  }
}

resource "aws_subnet" "public_b" {
  vpc_id                  = aws_vpc.main.id
  cidr_block              = "10.0.2.0/24"
  availability_zone       = "\${var.region}b"
  map_public_ip_on_launch = true

  tags = {
    Name = "${this.diagram.name}-public-b"
  }
}

resource "aws_subnet" "private" {
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.10.0/24"
  availability_zone = "\${var.region}a"

  tags = {
    Name = "${this.diagram.name}-private"
  }
}

resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = "${this.diagram.name}-igw"
  }
}

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }

  tags = {
    Name = "${this.diagram.name}-public-rt"
  }
}

resource "aws_route_table_association" "public_a" {
  subnet_id      = aws_subnet.public_a.id
  route_table_id = aws_route_table.public.id
}

resource "aws_route_table_association" "public_b" {
  subnet_id      = aws_subnet.public_b.id
  route_table_id = aws_route_table.public.id
}

resource "aws_db_subnet_group" "main" {
  name       = "${this.diagram.name}-db-subnet-group"
  subnet_ids = [aws_subnet.private.id, aws_subnet.public_a.id]

  tags = {
    Name = "${this.diagram.name}-db-subnet-group"
  }
}

resource "aws_elasticache_subnet_group" "main" {
  name       = "${this.diagram.name}-cache-subnet-group"
  subnet_ids = [aws_subnet.private.id]

  tags = {
    Name = "${this.diagram.name}-cache-subnet-group"
  }
}
`,
      language: 'hcl',
      description: 'VPC and networking resources',
    };
  }

  private generateSecurityTf(): IaCFile {
    let content = `# Security Groups

`;

    for (const node of this.diagram.nodes) {
      const resourceName = this.sanitizeName(node.id);
      const dependencies = this.findDependencies(node.id);

      content += `
resource "aws_security_group" "${resourceName}" {
  name        = "${resourceName}-sg"
  description = "Security group for ${node.data.label}"
  vpc_id      = aws_vpc.main.id

  # Ingress rules
`;

      // Add ingress rules based on dependencies
      if (node.type === 'loadBalancerNode') {
        content += `  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "HTTPS from internet"
  }

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "HTTP from internet"
  }
`;
      } else if (node.type === 'serverNode') {
        content += `  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/16"]
    description = "HTTP from VPC"
  }

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/16"]
    description = "HTTPS from VPC"
  }
`;
      } else if (node.type === 'databaseNode') {
        content += `  ingress {
    from_port   = 5432
    to_port     = 5432
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/16"]
    description = "PostgreSQL from VPC"
  }
`;
      }

      content += `
  # Egress rules
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow all outbound traffic"
  }

  tags = {
    Name = "${resourceName}-sg"
  }
}

`;
    }

    return {
      path: 'security.tf',
      content,
      language: 'hcl',
      description: 'Security group configurations',
    };
  }

  private generateModules(): IaCFile[] {
    // Generate reusable modules (stub)
    return [];
  }

  private extractResources(files: IaCFile[]): any[] {
    const resources: any[] = [];
    // Parse HCL to extract resources (simplified)
    return resources;
  }

  private sanitizeName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
  }
}

// ============================================================================
// Kubernetes Generator
// ============================================================================

export class KubernetesGenerator extends IaCGenerator {
  generate(): IaCOutput {
    const files: IaCFile[] = [];

    // Generate namespace
    files.push(this.generateNamespace());

    // Generate deployments for each service
    const serverNodes = this.getNodesByType('serverNode');
    for (const node of serverNodes) {
      files.push(this.generateDeployment(node));
      files.push(this.generateService(node));
    }

    // Generate databases as StatefulSets
    const databaseNodes = this.getNodesByType('databaseNode');
    for (const node of databaseNodes) {
      files.push(this.generateStatefulSet(node));
      files.push(this.generateService(node));
    }

    // Generate ingress for load balancers
    const lbNodes = this.getNodesByType('loadBalancerNode');
    if (lbNodes.length > 0) {
      files.push(this.generateIngress());
    }

    // Generate ConfigMap
    files.push(this.generateConfigMap());

    return {
      provider: 'kubernetes',
      files,
      resources: [],
    };
  }

  private generateNamespace(): IaCFile {
    return {
      path: 'namespace.yaml',
      content: `apiVersion: v1
kind: Namespace
metadata:
  name: ${this.sanitizeName(this.diagram.name)}
  labels:
    environment: ${this.options.environment}
    managed-by: system-design-visualizer
`,
      language: 'yaml',
      description: 'Kubernetes namespace',
    };
  }

  private generateDeployment(node: DiagramNode): IaCFile {
    const name = this.sanitizeName(node.id);
    const namespace = this.sanitizeName(this.diagram.name);

    return {
      path: `deployments/${name}.yaml`,
      content: `apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${name}
  namespace: ${namespace}
  labels:
    app: ${name}
    component: ${node.type}
spec:
  replicas: 3
  selector:
    matchLabels:
      app: ${name}
  template:
    metadata:
      labels:
        app: ${name}
    spec:
      containers:
      - name: ${name}
        image: ${name}:latest
        ports:
        - containerPort: 8080
          name: http
        env:
        - name: ENVIRONMENT
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: environment
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
`,
      language: 'yaml',
      description: `Deployment for ${node.data.label}`,
    };
  }

  private generateService(node: DiagramNode): IaCFile {
    const name = this.sanitizeName(node.id);
    const namespace = this.sanitizeName(this.diagram.name);

    return {
      path: `services/${name}-service.yaml`,
      content: `apiVersion: v1
kind: Service
metadata:
  name: ${name}
  namespace: ${namespace}
spec:
  selector:
    app: ${name}
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: ClusterIP
`,
      language: 'yaml',
      description: `Service for ${node.data.label}`,
    };
  }

  private generateStatefulSet(node: DiagramNode): IaCFile {
    const name = this.sanitizeName(node.id);
    const namespace = this.sanitizeName(this.diagram.name);

    return {
      path: `statefulsets/${name}.yaml`,
      content: `apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: ${name}
  namespace: ${namespace}
spec:
  serviceName: ${name}
  replicas: 1
  selector:
    matchLabels:
      app: ${name}
  template:
    metadata:
      labels:
        app: ${name}
    spec:
      containers:
      - name: ${name}
        image: postgres:15
        ports:
        - containerPort: 5432
          name: postgres
        env:
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: password
        volumeMounts:
        - name: data
          mountPath: /var/lib/postgresql/data
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 20Gi
`,
      language: 'yaml',
      description: `StatefulSet for ${node.data.label}`,
    };
  }

  private generateIngress(): IaCFile {
    const namespace = this.sanitizeName(this.diagram.name);

    return {
      path: 'ingress.yaml',
      content: `apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: main-ingress
  namespace: ${namespace}
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - ${this.diagram.name}.example.com
    secretName: tls-secret
  rules:
  - host: ${this.diagram.name}.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-gateway
            port:
              number: 80
`,
      language: 'yaml',
      description: 'Ingress configuration',
    };
  }

  private generateConfigMap(): IaCFile {
    const namespace = this.sanitizeName(this.diagram.name);

    return {
      path: 'configmap.yaml',
      content: `apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: ${namespace}
data:
  environment: ${this.options.environment}
  log_level: info
`,
      language: 'yaml',
      description: 'Application configuration',
    };
  }

  private sanitizeName(name: string): string {
    return name.replace(/[^a-z0-9-]/g, '-').toLowerCase();
  }
}

// ============================================================================
// IaC Generation Factory
// ============================================================================

export class IaCFactory {
  static generate(diagram: Diagram, config: IaCConfig): IaCOutput {
    switch (config.provider) {
      case 'terraform':
        return new TerraformGenerator(diagram, config.options).generate();
      case 'kubernetes':
        return new KubernetesGenerator(diagram, config.options).generate();
      default:
        throw new Error(`Unsupported IaC provider: ${config.provider}`);
    }
  }

  static async downloadIaC(output: IaCOutput, diagramName: string): Promise<void> {
    // Create a zip file with all generated files
    // For simplicity, download as separate files
    for (const file of output.files) {
      const blob = new Blob([file.content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = file.path;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
  }
}
